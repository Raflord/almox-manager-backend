// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: celuloseQueries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLoad = `-- name: CreateLoad :exec
INSERT INTO loads (id, material, average_weight, unit, created_at, timezone, operator, shift)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateLoadParams struct {
	ID            string           `json:"id"`
	Material      string           `json:"material"`
	AverageWeight int32            `json:"averageWeight"`
	Unit          string           `json:"unit"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	Timezone      pgtype.Text      `json:"timezone"`
	Operator      string           `json:"operator"`
	Shift         string           `json:"shift"`
}

func (q *Queries) CreateLoad(ctx context.Context, arg CreateLoadParams) error {
	_, err := q.db.Exec(ctx, createLoad,
		arg.ID,
		arg.Material,
		arg.AverageWeight,
		arg.Unit,
		arg.CreatedAt,
		arg.Timezone,
		arg.Operator,
		arg.Shift,
	)
	return err
}

const deleteLoad = `-- name: DeleteLoad :exec
DELETE FROM loads
WHERE id = $1
`

func (q *Queries) DeleteLoad(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteLoad, id)
	return err
}

const getFiltered = `-- name: GetFiltered :many
SELECT
    id, material, average_weight, unit, created_at, timezone, operator, shift
FROM
    loads
WHERE (material = $1
    OR NULLIF ($1, '') IS NULL)
AND ((NULLIF ($2, '') IS NOT NULL
        AND NULLIF ($3, '') IS NOT NULL
        AND created_at::date BETWEEN $2::date AND $3::date)
    OR (NULLIF ($2, '') IS NOT NULL
        AND NULLIF ($3, '') IS NULL
        AND created_at::date = $2::date)
    OR (NULLIF ($2, '') IS NULL
        AND NULLIF ($3, '') IS NULL))
ORDER BY
    created_at ASC
`

type GetFilteredParams struct {
	Material string      `json:"material"`
	Column2  interface{} `json:"column2"`
	Column3  interface{} `json:"column3"`
}

func (q *Queries) GetFiltered(ctx context.Context, arg GetFilteredParams) ([]Load, error) {
	rows, err := q.db.Query(ctx, getFiltered, arg.Material, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Load
	for rows.Next() {
		var i Load
		if err := rows.Scan(
			&i.ID,
			&i.Material,
			&i.AverageWeight,
			&i.Unit,
			&i.CreatedAt,
			&i.Timezone,
			&i.Operator,
			&i.Shift,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatest = `-- name: GetLatest :many
SELECT
    id, material, average_weight, unit, created_at, timezone, operator, shift
FROM
    loads
ORDER BY
    created_at DESC
LIMIT 10
`

func (q *Queries) GetLatest(ctx context.Context) ([]Load, error) {
	rows, err := q.db.Query(ctx, getLatest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Load
	for rows.Next() {
		var i Load
		if err := rows.Scan(
			&i.ID,
			&i.Material,
			&i.AverageWeight,
			&i.Unit,
			&i.CreatedAt,
			&i.Timezone,
			&i.Operator,
			&i.Shift,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSummary = `-- name: GetSummary :many
SELECT
    material,
    SUM(average_weight) AS total_weight
FROM
    loads
WHERE
    created_at::date = $1
GROUP BY
    material
`

type GetSummaryRow struct {
	Material    string `json:"material"`
	TotalWeight int64  `json:"totalWeight"`
}

func (q *Queries) GetSummary(ctx context.Context, createdAt pgtype.Timestamp) ([]GetSummaryRow, error) {
	rows, err := q.db.Query(ctx, getSummary, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSummaryRow
	for rows.Next() {
		var i GetSummaryRow
		if err := rows.Scan(&i.Material, &i.TotalWeight); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLoad = `-- name: UpdateLoad :exec
UPDATE
    loads
SET
    material = $1,
    created_at = $2,
    operator = $3,
    shift = $4
WHERE
    id = $5
`

type UpdateLoadParams struct {
	Material  string           `json:"material"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	Operator  string           `json:"operator"`
	Shift     string           `json:"shift"`
	ID        string           `json:"id"`
}

func (q *Queries) UpdateLoad(ctx context.Context, arg UpdateLoadParams) error {
	_, err := q.db.Exec(ctx, updateLoad,
		arg.Material,
		arg.CreatedAt,
		arg.Operator,
		arg.Shift,
		arg.ID,
	)
	return err
}
